#if defined(SHADOWS)
matrix pcWorldviewproj;
sampler pcShadow : register(s0);
float pcTexel;

matrix mainWorldviewproj;
sampler mainShadow : register(s1);
float mainTexel;
#endif

#if defined(DIFFUSE)
sampler diffuse : register(s2);
#endif

struct PS_INPUT
{
    vector diffuse : COLOR;
    vector vpos    : TEXCOORD0;
    float3 normal  : TEXCOORD1;
    float2 texcoord: TEXCOORD2;
};

struct PS_OUTPUT
{
    vector diffuse : COLOR;
};

#if defined(SHADOWS)
float unpack(vector color)
{
    const vector shifts = vector(1.0, 1.0 / 255.0, 1.0 / (255.0 * 255.0), 1.0 / (255.0 * 255.0 * 255.0));
    return dot(color, shifts);
}

float newsample(float2 c, float d, sampler shadow, float texel)
{
    float s = 0;

    for(float y = -1; y <= 1; ++y)
    {
        for(float x = -1; x <= 1; ++x)
        {
            float b = unpack(tex2D(shadow, c + float2(x * texel, y * texel)));
            if(b > d) ++s;
        }
    }

    return s * (1.0f / 9.0f);
}

float sampleShadow(PS_INPUT input, matrix worldviewproj, sampler shadow, float texel)
{
    vector diffuse = input.diffuse;

    vector pos = mul(input.vpos + vector(input.normal * 0.01f, 0), worldviewproj);

    float2 c = 0.5f * pos.xy / pos.w + float2(0.5f, 0.5f);
    c.y = 1.0f - c.y;

    float s = 1 - newsample(c, (1 - (pos.z / pos.w)) + 0.005f, shadow, texel);

    if(c.x >= 0 && c.x <= 1 && c.y >= 0 && c.y <= 1)
    {
        return 0.75f + (s * 0.25f);
    }

    return 1;
}
#endif

PS_OUTPUT main(PS_INPUT input)
{
    PS_OUTPUT output = (PS_OUTPUT)0;

#if defined(DIFFUSE)
    output.diffuse = input.diffuse * tex2D(diffuse, input.texcoord);
#else
    output.diffuse = input.diffuse;
#endif

#if defined(SHADOWS)
    if(dot(input.normal, float3(0, 1, 0)) >= 0.3f)
    {
        output.diffuse *= sampleShadow(input, mainWorldviewproj, mainShadow, mainTexel);
    }

    output.diffuse *= sampleShadow(input, pcWorldviewproj, pcShadow, pcTexel);
#endif

    output.diffuse.a = 1;
    return output;
}
